# Система инвалидации токенов

## Обзор

Система инвалидации токенов предназначена для обеспечения безопасности API путем блокировки JWT токенов, выданных ранее. Это позволяет реализовать функциональность выхода из всех устройств, принудительной смены пароля и отзыва прав доступа.

## Ключевые компоненты

1. **Таблица invalid_tokens в базе данных**
   - Хранит информацию о пользователях и времени инвалидации их токенов
   - Обеспечивает персистентность данных при перезапуске сервера

2. **InvalidTokenRepository**
   - Интерфейс для работы с данными об инвалидированных токенах
   - Реализация для PostgreSQL в `InvalidTokenRepo`

3. **JWTService**
   - Использует данные из репозитория и кэш в памяти
   - Проверяет токен на валидность, включая проверку на инвалидацию
   - Предоставляет методы для инвалидации токенов пользователя

## Принцип работы

1. При аутентификации пользователя в токене сохраняется время выдачи (`issuedAt`)
2. При выходе из системы или смене пароля токены пользователя инвалидируются путем сохранения времени инвалидации
3. При проверке токена сравнивается время выдачи токена с временем инвалидации:
   - Если токен был выдан до инвалидации, он считается недействительным
   - Если после инвалидации - действительным

## Методы JWTService

- `InvalidateTokensForUser(userID uint)` - инвалидирует все токены пользователя
- `ResetInvalidationForUser(userID uint)` - отменяет инвалидацию токенов пользователя
- `CleanupInvalidatedUsers()` - удаляет устаревшие записи об инвалидации

## Примеры использования

### Выход со всех устройств

```go
// В обработчике выхода с устройств
func (h *AuthHandler) LogoutAllDevices(c *fiber.Ctx) error {
    userID := getUserIDFromContext(c)
    err := h.jwtService.InvalidateTokensForUser(userID)
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Failed to invalidate tokens",
        })
    }
    return c.Status(fiber.StatusOK).JSON(fiber.Map{
        "message": "Logged out from all devices",
    })
}
```

### Смена пароля

```go
// В обработчике смены пароля
func (h *AuthHandler) ChangePassword(c *fiber.Ctx) error {
    // ... обработка смены пароля ...
    
    // Инвалидируем все старые токены
    err = h.jwtService.InvalidateTokensForUser(user.ID)
    if err != nil {
        // обработка ошибки
    }
    
    // Создаем новый токен
    token, err := h.jwtService.GenerateToken(user)
    // ... возврат нового токена ...
}
```

### Периодическая очистка

```go
// В main.go
// Запуск фоновой задачи
go func() {
    for {
        // Каждые 6 часов
        time.Sleep(6 * time.Hour)
        jwtService.CleanupInvalidatedUsers()
    }
}()
```

## Тестирование

Для тестирования системы инвалидации токенов разработан специальный скрипт:

```
go run cmd/token_test/test_token_invalidation.go [email]
```

- Без параметров: выполняет полный тест инвалидации
- С email: очищает инвалидацию для указанного пользователя 

## Лучшие практики и потенциальные проблемы

### Обновление профиля пользователя

При обновлении профиля пользователя следует использовать метод `UpdateProfile` вместо прямого обновления объекта пользователя. Это предотвращает нежелательное повторное хеширование пароля:

```go
// Правильно - использование специального метода
updates := map[string]interface{}{
    "username": newUsername,
    "profile_picture": newPicture,
}
userRepo.UpdateProfile(userID, updates)

// Неправильно - может привести к повторному хешированию пароля
user.Username = newUsername
userRepo.Update(user)
```

### Смена пароля

Для изменения пароля пользователя следует использовать отдельный метод `ChangePassword`, который:
1. Проверяет старый пароль
2. Хеширует новый пароль
3. Инвалидирует все существующие токены

```go
// В сервисе аутентификации
authService.ChangePassword(userID, oldPassword, newPassword)
```

### Известные проблемы и их решение

#### Проблема повторного хеширования

В предыдущих версиях API существовала проблема, когда метод `BeforeSave` хешировал пароль перед каждым сохранением пользователя, включая случаи, когда пароль уже был хеширован. Это приводило к:

1. Невозможности авторизации пользователя после обновления профиля
2. Накоплению последовательно хешированных паролей
3. Необходимости сброса пароля администратором

Эта проблема была решена путем добавления проверки в метод `BeforeSave`, который теперь хеширует пароль только если он не является bcrypt-хешем.

#### Обработка инвалидации токенов

Система инвалидации токенов может приводить к проблемам, если:
1. Одновременно происходит вход на нескольких устройствах
2. Накапливается большое количество устаревших инвалидаций

Рекомендуется:
- Регулярно запускать `CleanupInvalidatedUsers()` для очистки старых записей
- При смене пароля или выходе со всех устройств предупреждать пользователя о необходимости повторной авторизации

## Внесенные изменения (Декабрь 2023)

1. Исправлен метод `BeforeSave` в сущности `User` для предотвращения повторного хеширования пароля
2. Добавлены специализированные методы в `UserRepository`:
   - `UpdateProfile` для обновления пользовательской информации без пароля
   - `UpdatePassword` для безопасного обновления пароля
3. Добавлен новый метод `ChangePassword` в `AuthService` с корректной валидацией и инвалидацией токенов
4. Добавлен REST эндпоинт `/auth/change-password` для безопасной смены пароля 